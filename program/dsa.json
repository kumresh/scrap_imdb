[{"id":1,"name":"Data Structure","desc":"Data Structure is a way of storing and organizing data into the memory in a efficiently way. In another way we can say that It is the way of arranging data on a computer so that it can be accessed and update efficiently.","topic_when_use":[{"body":"Data structure provide reusability"},{"body":"It makes the program very efficient in term of time and space."}],"topic_type":[{"name":"Linear data structure","desc":"Data structure in which data element are arranged in sequential or linearly. Where each element is attached to it's previous and adjacent element, is called leaner data structure.","topic_type_ex":[{"name":"Array"},{"name":"Stack"},{"name":"Queue"},{"name":"Linked List"}]},{"name":"Non-linear data structure","desc":"Data structure where data elements are not in sequentially or linearly. Instead they are arranged in a hierarchical manner where one element will be connected to one or more elements.","topic_type_ex":[{"name":"Graph"},{"name":"Tree"},{"name":"Map"}]}],"topic_code":[],"topic_application":[]},{"id":2,"name":"Array","desc":"An Array is a linear data structure and it is a collection of similar data items stored in contiguous memory locations.","topic_when_use":[{"body":"Sorting and searching an element in an array is easier."},{"body":"Arrays are good for storing multiple values in a single variable"},{"body":"Arrays are best to process multiple values quickly and easily."}],"topic_type":[{"name":"One-Dimensional Arrays","desc":"1d array as a row, where elements are stored one after another.","topic_type_ex":[]},{"name":"Multi-Dimensional Arrays","desc":"An array of arrays is called a multi-dimensional array. In simple words, an array created with more than one dimension (size) is called a multi-dimensional array. The multi-dimensional array can be of a two-dimensional array or three-dimensional array or four-dimensional array or more.","topic_type_ex":[]}],"topic_code":[{"name":"Array","code":"from array import array\r\n\r\n# you can refer to official site for another data type\r\n# https://docs.python.org/3/library/array.html\r\n\"\"\"\r\n    \"b\" : signed char\r\n    \"i\": signed integer\r\n    \"I\": unsigned integer\r\n    \"l\": signed long etc\r\n\"\"\"\r\n\r\n\r\n# creating an array with integer type\r\nint_arr = array(\"i\", [12, 3, 4, 34, 34, 45])\r\nfor i in range(len(int_arr)):\r\n    print(f\"[{i}] ->  {int_arr[i]}\")\r\n\r\n\r\nprint(\"\\n\")\r\n\r\n# creating an array with float type\r\nfloat_arr = array(\"f\", [12.3, 23.8, 43.5, 2, 6])\r\nfor j in range(len(float_arr)):\r\n    print(f\"[{j}] ->  {float_arr[j]}\")\r\n\r\n\r\n# output:\r\n\r\n# [0] ->  12\r\n# [1] ->  3\r\n# [2] ->  4\r\n# [3] ->  34\r\n# [4] ->  34\r\n# [5] ->  45\r\n\r\n# [0] ->  12.300000190734863\r\n# [1] ->  23.799999237060547\r\n# [2] ->  43.5\r\n# [3] ->  2.0\r\n# [4] ->  6.0"}],"topic_application":[{"desc":"Arrays are used to implement data structures like a stack, queue, etc"},{"desc":"Arrays are good to implement Vectors and Lists."},{"desc":"As compared to pointers, arrays can be a better approach to implement Tree data structure."},{"desc":"Various mathematical problems like matrices can be easily and efficiently solved with the help of an array data structure."},{"desc":"The large data is managed by an array using a single variable name. It can maintain multiple variable names with a single name. Thus avoiding the confusion of using multiple variables."},{"desc":"The two-dimensional array (2D array) also called a matrix is used in image processing."}]},{"id":3,"name":"Linked list","desc":"Linked list is a linear data structure which contains a series of connected nodes. In which the node are randomly stored in the memory. Here, each node contains two parts, <b>data</b> and <b>address</b> of the next node.\r\n<br/><br/><i>The last node contains null in its second field because it will point to no node.\r\nA linked list can grow and shrink its size, as per the requirement.\r\nIt does not waste memory space.</i>","topic_when_use":[{"body":"Linked lists are really cheap to add or remove items anywhere and to iterate, but random access is O(n)."}],"topic_type":[{"name":"Singly Linked List","desc":"Singly Linked List is the most common. Each node has data and a pointer to the next node.","topic_type_ex":[]},{"name":"Doubly Linked List","desc":"There are three field in the Doubly Linked List, first field contain previous node address, second field contain data and the third field contain address of next node","topic_type_ex":[]},{"name":"Circular Linked List","desc":"The circular linked list is extremely similar to the singly linked list. The only difference is that the last node is connected with the first node, forming a circular loop in the circular linked list.","topic_type_ex":[]}],"topic_code":[{"name":"Singly Linked List","code":"# Singly Linked List\r\n\r\nclass Node:\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.next = None\r\n\r\n\r\nclass LinkedList:\r\n    def __init__(self):\r\n        self.head = None\r\n\r\n    def insertAtBeginning(self, value):\r\n        new_node = Node(value)\r\n        new_node.next = self.head\r\n        self.head = new_node\r\n\r\n    def insert(self, value):\r\n        if self.head is None:\r\n            print(\"insert item: \" + str(value))\r\n            self.head = Node(value)\r\n        else:\r\n\r\n            current_node = self.head\r\n            while current_node.next:\r\n                current_node = current_node.next\r\n            current_node.next = Node(value)\r\n            print(\"insert item: \" + str(value))\r\n\r\n    def remove(self):\r\n        \"\"\"\r\n        remove operation use O(n).\r\n        \"\"\"\r\n        current_node = self.head\r\n        if current_node is None:\r\n            print(\"Linked List is Empty\")\r\n        else:\r\n            temp = self.head\r\n            while temp.next is not None:\r\n                prev_node = temp\r\n                temp = temp.next\r\n            prev_node.next = None\r\n\r\n    def search(self, key):\r\n        \"\"\"\r\n        search operation use O(n).\r\n        \"\"\"\r\n        if self.length() != 0:\r\n            current_node = self.head\r\n            while current_node is not None:\r\n\r\n                if current_node.data == key:\r\n                    return f\"\\nElement Found: {key}\"\r\n                current_node = current_node.next\r\n            return \"Not Found\"\r\n\r\n    def printList(self):\r\n        \"\"\"\r\n        printList operation use O(n).\r\n        \"\"\"\r\n        if self.head is None:\r\n            print(\"Linked List is Empty\")\r\n        else:\r\n            current_node = self.head\r\n            while current_node is not None:\r\n                print(f\"[{current_node.data}] ->\", end=\" \")\r\n                current_node = current_node.next\r\n\r\n    def length(self):\r\n        count = 0\r\n        current = self.head\r\n        while current:\r\n            count += 1\r\n            current = current.next\r\n\r\n        return count\r\n\r\n\r\ndef main():\r\n    ll = LinkedList()\r\n    ll.insert(12)\r\n    ll.insert(32)\r\n    ll.insert(99)\r\n    ll.insert(53)\r\n    ll.printList()\r\n    ll.insertAtBeginning(262)\r\n    print(\"\\nAfter insert at beginning\")\r\n    ll.printList()\r\n\r\n    # print(ll.search(12))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n\r\n## Output\r\n\r\n# insert item: 12\r\n# insert item: 32\r\n# insert item: 99\r\n# insert item: 53\r\n# [12] -> [32] -> [99] -> [53] ->\r\n# After insert at beginning\r\n# [262] -> [12] -> [32] -> [99] -> [53] ->"}],"topic_application":[{"desc":"It is used for the dynamic memory location"},{"desc":"Implementing a hash table, each bucket or container of the hash table itself behaves as a linked list."},{"desc":"It is used in a functionality known as undo in Photoshop and Word."},{"desc":"To prevent the collision between the data in the hash table"}]},{"id":4,"name":"Stack","desc":"A Stack is a linear data structure that follows the LIFO (Last-In-First-Out) principle. It is similar to arrays and linked lists, restricting the random access of elements. In arrays or linked lists, you can access the items via traversal or random indexing, but the stack data structure doesn't allow it.","topic_when_use":[],"topic_type":[],"topic_code":[{"name":"Stack using List","code":"# Stack using List\r\n\r\n\r\nclass Stack:\r\n    def __init__(self):\r\n        self.container = []\r\n\r\n    def isEmpty(self):\r\n        return len(self.container) == 0\r\n\r\n    def push(self, data):\r\n        self.container.append(data)\r\n        print(\"push item: \" + str(data))\r\n\r\n    def pop(self):\r\n        if self.isEmpty():\r\n            print(\"Stack is Empty\")\r\n        return self.container.pop()\r\n\r\n    def peek(self):\r\n        if self.isEmpty():\r\n            print(\"Stack is Empty\")\r\n        return self.container[-1]\r\n\r\n    def display(self):\r\n        return self.container[::-1]\r\n\r\n\r\ndef main():\r\n    s = Stack()\r\n    s.push(12)\r\n    s.push(23)\r\n    s.push(43)\r\n    s.push(53)\r\n    s.push(2)\r\n    s.push(4)\r\n\r\n    print(s.display())\r\n\r\n    print(\"Peek item: \", s.peek())\r\n    s.pop()\r\n    print(\"\\nAfter pop operation\")\r\n    print(s.display())\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n\r\n# for reverse string\r\n# for expression evaluation\r\n# To check parenthesis matching in an expression\r\n# for Conversion from one form of expression to another\r\n# Used for Memory Management\r\n# Also used in backtracking problems\r\n\r\n\r\n# Output\r\n\r\n# push item: 12\r\n# push item: 23\r\n# push item: 43\r\n# push item: 53\r\n# push item: 2\r\n# push item: 4\r\n# [4, 2, 53, 43, 23, 12]\r\n# Peek item:  4\r\n\r\n# After pop operation\r\n# [2, 53, 43, 23, 12]"},{"name":"Stack using Linked List","code":"# Stack using Linked List\r\n\r\n\r\nclass Node:\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.next = None\r\n\r\n\r\nclass Stack:\r\n    def __init__(self):\r\n        self.head = None\r\n\r\n    def push(self, data):\r\n        \"\"\"\r\n        Push operation use O(1)\r\n        \"\"\"\r\n        if self.head is None:\r\n            self.head = Node(data=data)\r\n        else:\r\n            new_node = Node(data=data)\r\n            new_node.next = self.head\r\n            self.head = new_node\r\n\r\n    def isEmpty(self):\r\n        if self.head is None:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n    def pop(self):\r\n        if self.isEmpty():\r\n            print(\"Stack is Empty\")\r\n        else:\r\n            current_node = self.head\r\n            self.head = self.head.next\r\n            current_node.next = None\r\n            return current_node.data\r\n\r\n    def peek(self):\r\n        if self.isEmpty():\r\n            print(\"Stack is Empty\")\r\n\r\n        return self.head.data\r\n\r\n    def display(self):\r\n        if self.isEmpty():\r\n            print(\"Stack Underflow\")\r\n        else:\r\n            current_node = self.head\r\n            while current_node is not None:\r\n                print(f\"[{current_node.data}] ->\", end=\" \")\r\n                current_node = current_node.next\r\n\r\n\r\ndef main():\r\n    s = Stack()\r\n    s.push(12)\r\n    s.push(23)\r\n    s.push(43)\r\n    s.push(53)\r\n    s.push(2)\r\n    s.push(4)\r\n\r\n    print(s.display())\r\n\r\n    print(\"Peek item: \", s.peek())\r\n    s.pop()\r\n    print(\"After pop operation\")\r\n    print(s.display())\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n\r\n# Output\r\n\r\n# [4] -> [2] -> [53] -> [43] -> [23] -> [12] -> None\r\n# Peek item:  4\r\n# After pop operation\r\n# [2] -> [53] -> [43] -> [23] -> [12] -> None"}],"topic_application":[{"desc":"Stacks are used to convert expressions from one form to another"},{"desc":"The stacks are used for parentheses checking expressions"},{"desc":"The stacks are used for expression evaluation"},{"desc":"The stacks can be used as backtracking"},{"desc":"The stacks are also used for string reversal"},{"desc":"Memory management and function are the application of stacks"}]},{"id":5,"name":"Queue","desc":"A queue is a linear data structure like a stack having some restrictions on insertion and deletion. In a queue, insertion is performed at one end, and the removal is performed at another or opposite end.","topic_when_use":[],"topic_type":[{"name":"Simple Queue","desc":"In Linear Queue, an insertion takes place from one end while the deletion occurs from another end. The end at which the insertion takes place is known as the rear end, and the end at which the deletion takes place is known as front end. It strictly follows the FIFO rule.","topic_type_ex":[]},{"name":"Circular Queue","desc":"In Circular Queue, all the nodes are represented as circular. It is similar to the linear Queue except that the last element of the queue is connected to the first element. It is also known as Ring Buffer, as all the ends are connected to another end.","topic_type_ex":[]},{"name":"Priority Queue","desc":"It is a special type of queue in which the elements are arranged based on the priority. It is a special type of queue data structure in which every element has a priority associated with it. Suppose some elements occur with the same priority, they will be arranged according to the FIFO principle.","topic_type_ex":[]}],"topic_code":[{"name":"Queue using List","code":"# Queue using List\r\n\r\n\r\nclass Queue:\r\n    def __init__(self):\r\n        self.container = []\r\n\r\n    def enqueue(self, data):\r\n        self.container.append(data)\r\n        print(\"enqueue item: \" + str(data))\r\n\r\n    def dequeue(self):\r\n        if len(self.container) < 1:\r\n            return None\r\n        return self.container.pop(0)\r\n\r\n    def peek(self):\r\n        if self.isEmpty():\r\n            print(\"Queue is Empty\")\r\n        return self.container[0]\r\n\r\n    def isEmpty(self):\r\n        return len(self.container) == 0\r\n\r\n    def rear(self):\r\n        return self.container[-1]\r\n\r\n    def front(self):\r\n        return self.container[0]\r\n\r\n    def display(self):\r\n        return self.container\r\n\r\n\r\ndef main():\r\n    q = Queue()\r\n    q.enqueue(12)\r\n    q.enqueue(24)\r\n    q.enqueue(43)\r\n    q.enqueue(53)\r\n    q.enqueue(56)\r\n    q.enqueue(46)\r\n\r\n    print(q.display())\r\n    q.dequeue()\r\n    print(q.display())\r\n    print(\"Rear: item : \", q.rear())\r\n    print(\"Front item: \", q.front())\r\n\r\n\r\nmain()\r\n\r\n\r\n# * Handling request\r\n# * CPU scheduling\r\n# * Handling of interrupts in real-time systems\r\n# * Call center use queue to hold people while call\r\n\r\n\r\n# output:\r\n\r\n# enqueue item: 12\r\n# enqueue item: 24\r\n# enqueue item: 43\r\n# enqueue item: 53\r\n# enqueue item: 56\r\n# enqueue item: 46\r\n# [12, 24, 43, 53, 56, 46]\r\n# [24, 43, 53, 56, 46]\r\n# Rear: item :  46\r\n# Front item:  24"}],"topic_application":[]},{"id":6,"name":"Tree","desc":"A tree is a nonlinear hierarchical data structure which is a collection of object or entities which is also known as node. It connects each node in the tree data structure using \"edgesâ€, both directed and undirected.","topic_when_use":[],"topic_type":[{"name":"Binary Tree","desc":"","topic_type_ex":[]},{"name":"Binary Search Tree","desc":"","topic_type_ex":[]},{"name":"B-Tree","desc":"","topic_type_ex":[]},{"name":"AVL Tree","desc":"","topic_type_ex":[]}],"topic_code":[],"topic_application":[{"desc":"Binary Search Tree (BST) are used to quickly check whether an element is present in a set or not."},{"desc":"Databases use B-Trees and B+Trees for indexing"},{"desc":"Compilers use a syntax tree to validate the syntax of every program you write."},{"desc":"The tree data structure is also used to store the data in routing tables in the routers."}]},{"id":7,"name":"Tree Traversal","desc":"Traversal of the tree in data structures is a process of visiting each node and prints their value. There are three ways to traverse tree data structure.","topic_when_use":[],"topic_type":[{"name":"In-Order Traversal","desc":"In the in-order traversal, the left subtree is visited first, then the root, and later the right subtree.<br/>Step 1:  Recursively traverse the left subtree.<br/>Step 2: Visit root node<br/>Step 3: Recursively traverse right subtree<br/>","topic_type_ex":[]},{"name":"Pre-Order Traversal","desc":"In pre-order traversal, it visits the root node first, then the left subtree, and lastly right subtree.<br/>Step 1: Visit root node<br/>Recursively traverse the left subtree<br/>Step 3: Recursively traverse right subtree<br/>","topic_type_ex":[]},{"name":"Post-Order Traversal","desc":"It visits the left subtree first in post-order traversal, then the right subtree, and finally the root node.<br/>Step 1: Recursively traverse the left subtree<br/>Step 2: Visit root node<br/>Step 3: Recursively traverse right subtree","topic_type_ex":[]}],"topic_code":[],"topic_application":[]},{"id":8,"name":"Doubly Linked List","desc":"A doubly linked list is a data structure where a set of sequential links of records called nodes exist. Unlike the singly linked list, a node of a doubly linked list consists of three fields: two link fields and one information field. Two link fields provide information about the address of previous nodes and the next nodes in the sequence and one data field.","topic_when_use":[{"body":"Other data structures like stacks, Hash Tables, Binary trees can also be constructed or programmed using a doubly-linked list."}],"topic_type":[],"topic_code":[{"name":"Doubly Linked List","code":"# Doubly Linked List\r\n\r\n\r\nclass Node:\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.next = None\r\n        self.prev = None\r\n\r\n\r\nclass DoublyLinkedList:\r\n    def __init__(self):\r\n        self.head = None\r\n\r\n    def insert(self, data):\r\n        if self.head is None:\r\n            self.head = Node(data)\r\n            print(\"insert item: \" + str(data))\r\n        else:\r\n            current_node = self.head\r\n            while current_node.next is not None:\r\n                current_node = current_node.next\r\n            new_node = Node(data)\r\n            current_node.next = new_node\r\n            new_node.prev = current_node\r\n            print(\"insert item: \" + str(data))\r\n\r\n    def deleteAtStart(self):\r\n        if self.head is None:\r\n            print(\"Linked list is empty, no element is to delete\")\r\n        elif self.head.next is None:\r\n            self.head = None\r\n        self.head = self.head.next\r\n        self.head.prev = None\r\n\r\n    def deleteAtEnd(self):\r\n        if self.head is None:\r\n            print(\"Linked list is empty, no element is to delete\")\r\n        elif self.head.next is None:\r\n            self.head = None\r\n        current_node = self.head\r\n        while current_node.next is not None:\r\n            current_node = current_node.next\r\n        current_node.prev.next = None\r\n\r\n    def display(self):\r\n        if self.head is None:\r\n            print(\"linked is Empty\")\r\n        else:\r\n            current_node = self.head\r\n            while current_node is not None:\r\n                print(f\"[{current_node.data}] ->\", end=\" \")\r\n                current_node = current_node.next\r\n\r\n\r\ndef main():\r\n    dl = DoublyLinkedList()\r\n    dl.insert(12)\r\n    dl.insert(32)\r\n    dl.insert(99)\r\n    dl.insert(53)\r\n    dl.display()\r\n\r\n\r\nmain()\r\n\r\n#\r\n# - A music player which has next and prev buttons.\r\n# - Represent a deck of cards in a game.\r\n# - The browser cache which allows you to hit the BACK-FORWARD pages.\r\n# - Applications that have a Most Recently Used list (a linked list of file names)\r\n# - Undo-Redo functionality\r\n\r\n\r\n# output:\r\n\r\n# insert item: 12\r\n# insert item: 32\r\n# insert item: 99\r\n# insert item: 53\r\n# [12] -> [32] -> [99] -> [53] ->"}],"topic_application":[{"desc":"It is used by the browser to implement backward and forward navigation of visited web pages that is a back and forward button."},{"desc":"It is also used to represent a classic game deck of cards."},{"desc":"Doubly Linked List is also used in constructing MRU/LRU (Most/least recently used) cache."},{"desc":"Also in many operating systems, the thread scheduler(the thing that chooses what process needs to run at which time) maintains a doubly-linked list of all processes running at that time."}]},{"id":9,"name":"Circular Linked List","desc":"The circular linked list is extremely similar to the singly linked list. The only difference is that the last node is connected with the first node, forming a circular loop in the circular linked list.","topic_when_use":[],"topic_type":[],"topic_code":[{"name":"Circular Linked List","code":"# Circular Linked List\r\n\r\n\r\nclass Node:\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.next = None\r\n\r\n\r\nclass CircularLinkedList:\r\n    def __init__(self):\r\n        self.tail = None\r\n\r\n    def isEmpty(self):\r\n        return self.tail == None\r\n\r\n    def insertAtFront(self, data):\r\n        if self.isEmpty():\r\n            new_node = Node(data)\r\n            self.tail = new_node\r\n            new_node.next = new_node\r\n        else:\r\n            new_node = Node(data)\r\n            new_node.next = self.tail.next\r\n            self.tail.next = new_node\r\n\r\n    def insertAtEnd(self, data):\r\n        new_node = Node(data)\r\n        if self.isEmpty():\r\n            self.tail = new_node\r\n            new_node.next = new_node\r\n        else:\r\n            new_node.next = self.tail.next\r\n            self.tail.next = new_node\r\n            self.tail = new_node\r\n\r\n    def deleteFirst(self):\r\n        if self.isEmpty():\r\n            print(\"Linked list is Empty\")\r\n        elif self.tail.next == self.tail:\r\n            self.tail.next = None\r\n            self.tail = None\r\n        first_node = self.tail.next\r\n        second_node = first_node.next\r\n        self.tail.next = second_node\r\n\r\n    def display(self):\r\n        if self.isEmpty():\r\n            print(\"Linked list is Empty\")\r\n        last_node = self.tail\r\n        current_node = self.tail.next\r\n        while current_node:\r\n            print(f\"[{current_node.data}] ->\", end=\" \")\r\n            if current_node == last_node:\r\n                break\r\n            current_node = current_node.next\r\n        print(\"\\n\")\r\n\r\n\r\ndef main():\r\n    ll = CircularLinkedList()\r\n    ll.insertAtEnd(12)\r\n    ll.insertAtEnd(32)\r\n    ll.insertAtEnd(99)\r\n    ll.display()\r\n    ll.insertAtFront(53)\r\n    ll.insertAtFront(14)\r\n    ll.display()\r\n\r\n\r\nmain()\r\n\r\n# To implementation of advanced data structures like Fibonacci Heap\r\n# Multiplayer games to swap between players in loop\r\n# Undo function in App like word, paint etc.\r\n\r\n# output:\r\n\r\n# [12] -> [32] -> [99] ->\r\n\r\n# [14] -> [53] -> [12] -> [32] -> [99] ->"}],"topic_application":[{"desc":"Circular Linked Lists can be used to manage the computing resources of the computer."},{"desc":"Data structures such as stacks and queues are implemented with the help of the circular linked lists."},{"desc":"Circular Linked List is also used in the implementation of advanced data structures such as a Fibonacci Heap."},{"desc":"It is also used in computer networking for token scheduling."},{"desc":"Personal Computers, where multiple applications are running. All the running applications are kept in a circular linked list and the OS gives a fixed time slot to all for running. The Operating System keeps on iterating over the linked list until all the applications are completed."},{"desc":"Another example can be Multiplayer games. All the Players are kept in a Circular Linked List and the pointer keeps on moving forward as a player's chance ends."},{"desc":"Circular Linked List can also be used to create Circular Queue. In a Queue we have to keep two pointers, FRONT and REAR in memory all the time, where as in Circular Linked List, only one pointer is required."}]},{"id":10,"name":"Graph","desc":"A graph is a no-linear data structure that consist of vertices(Node) and edges. It consists of a finite set of vertices and set of edges that connect a pair of node. Graph is used to solve the most challenging and complex programming problems. It has different terminologies which are path, Degree, Adjacent Vertices, Connected components, etc.","topic_when_use":[],"topic_type":[],"topic_code":[],"topic_application":[{"desc":"Graph is used to represent the flow of computation."},{"desc":"It is used in modeling graph."},{"desc":"The operating system uses resource allocation Graph."},{"desc":"Also used in the <b>World Wide Web</b> where the web pages represent the nodes."}]}]